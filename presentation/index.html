<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Functional Wrappers for legacy APIs</title>

		<meta name="description" content="A design approach for leveraging functional programming in non-functional organizations and projects">
		<meta name="author" content="Martin Snyder">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h1>Functional Wrappers for legacy APIs</h1>
					<p>
						<small><a href="http://martinsnyder.net">Martin Snyder</a> / <a href="https://twitter.com/MartinSnyder">@MartinSnyder</a></small>
					</p>
				</section>

				<section>
					<h2>Goals for technology introduction</h2>
                    <ul>
                        <li>Lower adoption cost</li>
                        <li>Showcase the strengths of the technology</li>
                        <li>Give an immediate, concrete benefit</li>
                    </ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h2>Attributes of Functional Programming</h2>
                    <ul>
                        <li>Immutable data</li>
                        <li>Elimination of side effects</li>
                        <li>Higher order functions</li>
                        <li>Robust collection APIs</li>
                        <li>What to do, not how to do it</li>
                    </ul>
					<aside class="notes">
					What is a side effect?  Describe a side effect as a mutation of somethign unseen (global state or otherwise).
					
					Scala offers functional programming on the JVM, with excellent Java interop
					</aside>
				</section>

				<section>
					<h2>Example - Scala wrapper for JDBC</h2>
					<p>The value is in the process, not the product.  This example was selected for the following reasons:</p>
                    <ul>
                        <li>JDBC is a highly accessible technology</li>
                        <li>Scala is a JVM language with great Java interopability</li>
                        <li>The combination lends itself to self-contained examples</li>
                        <li>Representative of more interesting problems</li>
                    </ul>
					<aside class="notes">
						Note this has been done before (often) and more comprehensively
					</aside>
				</section>

				<section>
					<section>
						<h2>The Destination</h2>
<pre><code>def queryToJSON(conn: Jdbc.ConnectionInfo, sql: String) = {
    val mapper = new ObjectMapper()
    mapper.registerModule(DefaultScalaModule)
 
    Jdbc.withResultsIterator(conn, sql, (it) => {
        val jsonIt = it.map(row => mapper.writeValueAsString(row))
 
        jsonIt.mkString("[\n\t", ",\n\t", "\n]")
    })
}

def main(args: Array[String]) {
  queryToJSON(connectionInfo, "SELECT * FROM EXAMPLE") match {
    case Success(json) => println(json)
    case Failure(e) => println(e.getMessage)
  }
}</code></pre>
                        <aside class="notes">
						</aside>
					</section>

					<section>
						<h2>Sample Data</h2>
<pre><code>CREATE TABLE EXAMPLE(ID INT PRIMARY KEY, DESCRIPTION VARCHAR);
INSERT INTO EXAMPLE(ID, DESCRIPTION) VALUES(0, 'Zero');
INSERT INTO EXAMPLE(ID, DESCRIPTION) VALUES(1, 'One');
INSERT INTO EXAMPLE(ID, DESCRIPTION) VALUES(2, 'Two');
INSERT INTO EXAMPLE(ID, DESCRIPTION) VALUES(3, 'Three');
INSERT INTO EXAMPLE(ID, DESCRIPTION) VALUES(4, 'Four');</code></pre>
						<aside class="notes">
						</aside>
					</section>

					<section>
						<h2>Example Output</h2>
<pre><code>[
	{"DESCRIPTION":"Zero","ID":0},
	{"DESCRIPTION":"One","ID":1},
	{"DESCRIPTION":"Two","ID":2},
	{"DESCRIPTION":"Three","ID":3},
	{"DESCRIPTION":"Four","ID":4}
]</code></pre>
						<aside class="notes">
						</aside>
					</section>

					<section>
						<h2>Partial result sets</h2>
<pre><code>def queryToJSON(conn: Jdbc.ConnectionInfo, sql: String) = {
    val mapper = new ObjectMapper()
    mapper.registerModule(DefaultScalaModule)
 
    Jdbc.withResultsIterator(conn, sql, (it) => {
        val jsonIt = it.map(row => mapper.writeValueAsString(row))
 
        jsonIt.drop(2).take(2).mkString("[\n\t", ",\n\t", "\n]")
    })
}
</code></pre>
						<aside class="notes">
						</aside>
					</section>
				</section>

				<section>
					<h2>The Approach</h2>
                    <ul>
                        <li>Hide state from our callers</li>
                        <li>Surface within the collections API</li>
                    </ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h2>The starting point</h2>
<pre><code>Connection conn =  DriverManager.getConnection("url", "user", "pass");
try {
	Statement stmt = conn.createStatement();
	try {
		ResultSet rs = stmt.executeQuery("SELECT * FROM EX");
		try {
			while (rs.next()) { ... }
		} finally {
			rs.close();
		}
	} finally {
		stmt.close();
	}
} finally {
	conn.close();
}
</code></pre>
					<aside class="notes">
						The key point on this slide is state management as it relates to the 3 primary JDBC API objects and their open/closed status
					</aside>
				</section>

				<section>
					<section>
						<h2>Step 1 - Hiding Connection State</h2>
                        <ul>
                            <li>Connection, Statement, and ResultSet all have an internal state that must be managed</li>
                            <li>Requires developer knowledge for correct use</li>
                            <li>Potential source of programmer errors</li>
                        </ul>
						<aside class="notes">
						</aside>
					</section>

					<section>
						<h2>Create Data Payload</h2>
<pre><code>case class ConnectionInfo(
	url: String,
	username: String,
	password: String)</code></pre>
						<aside class="notes">
							We need this because we will need to represent "what we need to connect to a DB"
						</aside>
					</section>

					<section>
						<h2>Introduce Higher Order Function</h2>
<pre><code>def withConnection (connInfo: ConnectionInfo,
	f: (Connection) => Unit) {
		...
	}</code></pre>
						<aside class="notes">
						</aside>
					</section>
					
					<section>
						<h2>Control State Management</h2>
<pre><code>def withConnection (connInfo: ConnectionInfo,
	f: (Connection) => Unit) {
		val conn = DriverManager.getConnection(connInfo.url,
				connInfo.username,
				connInfo.password)
		try {
			f(conn)
		}
		finally {
			conn.close()
		}
	}</code></pre>
						<aside class="notes">
						</aside>
					</section>

					<section>
						<h2>Use Generic Return Types</h2>
<pre><code>def withConnection [T] (connInfo: ConnectionInfo,
	f: (Connection) => T): T = {
		val conn = DriverManager.getConnection(connInfo.url,
				connInfo.username,
				connInfo.password)
		try {
			f(conn)
		}
		finally {
			conn.close()
		}
	}</code></pre>
						<aside class="notes">
						</aside>
					</section>

                    <section>
                        <h2>Apply the Try Monad</h2>
<pre><code>def withConnection [T] (connInfo: ConnectionInfo,
    f: (Connection) => T): Try[T] = {
        val conn = DriverManager.getConnection(connInfo.url,
            connInfo.username,
            connInfo.password)
        val result = Try(f(conn))
        conn.close()
        result
    }</code></pre>
                        <aside class="notes">
                        </aside>
                    </section>
				</section>

                <section>
                    <section>
                        <h2>Step 1a - Hide more state</h2>
                        <p>Now we finish the job for Statement and ResultSet</p>
                        <aside class="notes">
                        </aside>
                    </section>

                    <section>
                        <h2>Statement Management</h2>
<pre><code>def withStatement [T] (connInfo: ConnectionInfo,
    f: (Statement) => T): Try[T] = {
        def privFun(conn: Connection) = {
            val stmt = conn.createStatement()
            try {
                f(stmt)
            }
            finally {
                stmt.close()
            }
        }

        withConnection(connInfo, privFun)
    }</code></pre>
                        <aside class="notes">
                        </aside>
                    </section>

                    <section>
                        <h2>ResultSet Management</h2>
<pre><code>def withResultSet [T] (connInfo: ConnectionInfo, sql: String,
    f: (ResultSet) => T): Try[T] = {
        def privFun(stmt: Statement) = {
            val resultSet = stmt.executeQuery(sql)
            try {
                f(resultSet)
            }
            finally {
                resultSet.close()
            }
        }

        withStatement(connInfo, privFun)
    }</code></pre>
                        <aside class="notes">
                        </aside>
                    </section>

                </section>

                <section>
                    <h2>Progress check</h2>
                    <p>Our risk profile is about the same as before because of the complexity of the ResultSet interface which combines:
                    <ul>
                        <li>State regarding the result set</li>
                        <li>Iteration</li>
                        <li>Data structure of the results</li>
                        <li>Read access to the “current” row</li>
                        <li>Write access to the “current” row</li>
                    </ul>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <section>
                        <h2>Step 2 - Plug into the collections API</h2>
                        <p>There are three appropriate "iterable" collection objects in Scala:
                        <ul>
                            <li>List</li>
                            <li>Iterator</li>
                            <li>Stream</li>
                        </ul>
                        <aside class="notes">
                        </aside>
                    </section>

                    <section>
                        <h2>A Naive Iterator</h2>
<pre><code>class ResultsIterator(resultSet: ResultSet) extends Iterator[ResultSet]
{
    def hasNext = resultSet.next()
    def next() = resultSet
}</code></pre>
                        <aside class="notes">
                        </aside>
                    </section>

                    <section>
                        <h2>Extract our column names</h2>
<pre><code>private val columnNames: List[String] = {
    val rsmd: ResultSetMetaData = resultSet.getMetaData

    val columnNamesBuf = new ListBuffer[String]
    for (i <- 1 to rsmd.getColumnCount) {
        columnNamesBuf.append(rsmd.getColumnName(i))
    }

    columnNamesBuf.toList
}</code></pre>
                        <aside class="notes">
                        </aside>
                    </section>

                    <section>
                        <h2>Extracting One Row</h2>
<pre><code>private def buildRowMap(resultSet: ResultSet) = {
    val rowMap = new scala.collection.mutable.HashMap[String, AnyRef]

    columnNames.foreach((columnName: String) => {
        rowMap.put(columnName, resultSet.getObject(columnName))
    })

    rowMap.toMap
}</code></pre>
                        <aside class="notes">
                        </aside>
                    </section>

                    <section>
                        <h2>An Improved Iterator</h2>
<pre><code>class ResultsIterator (resultSet: ResultSet)
    extends Iterator[Map[String, AnyRef]] {
        val columnNames = { … }
        private def buildRowMap(resultSet: ResultSet) = { ... }

        def hasNext = resultSet.next()
        def next() = buildRowMap(resultSet)
    }</code></pre>
                        <aside class="notes">
                        </aside>
                    </section>

                    <section>
                        <h2>Controlling Row Retrieval</h2>
<pre><code>private def getNextRow(resultSet: ResultSet) = {
    if (resultSet.next())
        Some(buildRowMap(resultSet))
    else
        None
}</code></pre>
                        <aside class="notes">
                        </aside>
                    </section>

                    <section>
                        <h2>The Final Iterator</h2>
<pre><code>class ResultsIterator (resultSet: ResultSet)
    extends Iterator[Map[String, AnyRef]]
    {
        val columnNames = { … }
        private def buildRowMap(resultSet: ResultSet) = { … }
        private def getNextRow(resultSet: ResultSet) = { … }

        var nextRow = getNextRow(resultSet)

        def hasNext = nextRow.isDefined

        def next() = {
            val rowData = nextRow.get
            nextRow = getNextRow(resultSet)
            rowData
        }
    }</code></pre>
                        <aside class="notes">
                        </aside>
                    </section>




                </section>





            </div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
